<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KRCG Graphic Generator</title>
    <style>
        @font-face {
            font-family: 'Genk';
            src: url(data:font/otf;base64,T1RUTwALAIAAAwAwQ0ZGIPwCByUAAARwAAANn0dERUYADwAeAAASEAAAABRHU1VCqSq2HwAAEiQAAABQT1MvMmc9YSsAAAHMAAAAYGNtYXACEgGsAAAD5AAAAGxoZWFkLKJ7mgAAAMQAAAA2aGhlYQeDAqsAAAGoAAAAJGhtdHgm4QLQAAAA/AAAAKxtYXhwACtQAAAAALwAAAAGbmFtZSCbPPEAAAIsAAABtnBvc3T/nwAyAAAEUAAAACAAAFAAACsAAAABAAAAAQAARFOtZF8PPPUAAwPoAAAAAOWOnGYAAAAA5Y6cZgAJ/+gCZQICAAAABwACAAAAAAAAAPoALwAjAAAA3AARANwAEQDcABEA3AARAJwAEQCcABEA3AARANwAEQBuABEA3AARANwAEQCSABEBSgARANwAEQDcABEA3AARAN0AEQDcABEA3AARALYACQDcABEA3AARAUoAEQDcABEA3AARANwAEQDcABEA3AARAHkACQDcABEA3AARANwAEQDcABEA3AARANwAEQDcABEA3AARASQACQH4ABEBSgARAnYAEQABAAACWAAAArwCdgAJAAkCZQABAAAAAAAAAAAAAAAAAAAAKwAEAOcBkAAFAAgCigJYAAAASwKKAlgAAAFeADIA+gAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAABVS1dOAMAAIACgAfQAAAK8AlgAGAAAAAEAAAAAAfQB9AAAACAAAgAAAAgAZgADAAEECQABACQAAAADAAEECQACAA4AJAADAAEECQADAEgAMgADAAEECQAEADQAegADAAEECQAFAD4ArgADAAEECQAGADIA7AADAAEECQAQABQBHgADAAEECQARAB4BMgBnAGUAbgBrADIANgAwADEAMQA1ACAAUgBvAHUAbgBkAGUAZABSAGUAZwB1AGwAYQByADEALgAwADAAMAA7AFUASwBXAE4AOwBnAGUAbgBrADIANgAwADEAMQA1AC0AUgBlAGcAdQBsAGEAcgBSAG8AdQBuAGQAZQBkAGcAZQBuAGsAMgA2ADAAMQAxADUAIABSAGUAZwB1AGwAYQByACAAUgBvAHUAbgBkAGUAZABWAGUAcgBzAGkAbwBuACAAMQAuADAAMAAwADsARwBsAHkAcABoAHMAIAAzAC4ANQAgACgAMwA1ADAAOQApAGcAZQBu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) format('opentype');
            font-weight: normal;
            font-style: normal;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        body {
            background: #001550;
            color: #82CDFF;
            display: flex;
            gap: 24px;
            padding: 24px;
        }

        /* Left Sidebar */
        .sidebar-left {
            width: 200px;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .sidebar-left-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Right Sidebar */
        .sidebar-right {
            width: 200px;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex-shrink: 0;
        }

        /* Header/Logo */
        .header {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .header-icon {
            font-family: 'Genk', sans-serif;
            font-size: 34px;
            color: #86d9ff;
            line-height: 0.78;
        }

        .header-title {
            font-size: 12px;
            color: #82cdff;
        }

        /* Panel Styles */
        .panel {
            background: #0d2159;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
        }

        .panel-dark {
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
        }

        /* Text Input */
        .text-input {
            width: 100%;
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
            color: #82CDFF;
            font-family: inherit;
            font-size: 12px;
            letter-spacing: 0.12px;
        }
        .text-input:focus {
            outline: none;
            border-color: #82CDFF;
        }
        .text-input::placeholder {
            color: #82CDFF;
            opacity: 0.6;
        }

        /* Control Labels */
        .control-label {
            font-size: 12px;
            color: #82CDFF;
            margin-bottom: 12px;
            display: block;
        }

        /* Color Swatches */
        .color-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .color-swatches {
            display: flex;
            gap: 6px;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .color-swatch:hover,
        .color-swatch.active {
            border-color: #334473;
        }

        /* Grid Toggle */
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
        }

        .toggle-label {
            font-size: 12px;
            color: #82CDFF;
        }

        .toggle-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #82CDFF;
        }

        /* Slider Styles */
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .slider-label {
            font-size: 12px;
            color: #82CDFF;
        }

        .slider-value {
            font-size: 8px;
            font-weight: bold;
            color: #82CDFF;
            background: transparent;
            border: none;
            text-align: right;
            width: 40px;
        }

        .slider-value:focus {
            outline: none;
            color: #FFFFFF;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slider-track {
            flex: 1;
            height: 2px;
            background: #1a2c62;
            border-radius: 12px;
            position: relative;
            display: flex;
            align-items: center;
        }

        .slider {
            width: 100%;
            height: 12px;
            -webkit-appearance: none;
            background: transparent;
            cursor: pointer;
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .slider::-webkit-slider-runnable-track {
            height: 2px;
            background: #1a2c62;
            border-radius: 12px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #82CDFF;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -5px;
        }

        .reset-btn {
            width: 16px;
            height: 16px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .reset-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Canvas Size Buttons */
        .size-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .size-btn {
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
            color: #82CDFF;
            font-size: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .size-btn:hover {
            border-color: #82CDFF;
        }

        .size-btn.active {
            border-color: #82CDFF;
            background: #82CDFF;
            color: #001550;
        }

        /* Easing Curve Editor */
        .easing-container {
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
            position: relative;
        }

        #easingCanvas {
            width: 100%;
            aspect-ratio: 1;
            display: block;
            cursor: crosshair;
        }

        .easing-point {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #82CDFF;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .easing-input {
            width: 100%;
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
            color: #82CDFF;
            font-size: 8px;
            font-weight: bold;
            text-align: center;
            margin-top: 12px;
        }

        .easing-input:focus {
            outline: none;
            border-color: #82CDFF;
        }

        /* Output Buttons */
        .output-buttons {
            display: flex;
            gap: 6px;
        }

        .output-btn {
            flex: 1;
            background: #1a2c62;
            border: 1px solid #334473;
            border-radius: 6px;
            padding: 12px;
            color: #82CDFF;
            font-size: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .output-btn:hover {
            background: #82CDFF;
            color: #001550;
        }

        .output-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Canvas Container */
        #canvas-container {
            flex: 1;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            background: #82CDFF;
            border-radius: 12px;
        }

        #canvas-container canvas {
            display: block;
            transform-origin: center center;
        }

        #grid-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            pointer-events: none;
            display: none;
            transform-origin: center center;
            z-index: 10;
        }

        #grid-overlay.visible {
            display: block;
        }

        /* Branding Footer */
        .branding {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .branding-icon {
            width: 17px;
            height: 17px;
        }

        .branding-text {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .branding-label {
            font-size: 7px;
            color: #82CDFF;
            letter-spacing: -0.14px;
        }

        .branding-name {
            font-size: 14px;
            font-weight: 600;
            color: #82CDFF;
            text-transform: uppercase;
            letter-spacing: 0.14px;
            display: flex;
            align-items: flex-start;
        }

        .branding-copyright {
            font-size: 4px;
            vertical-align: super;
            margin-left: 1px;
        }

        /* Multi-slider panels */
        .slider-panel {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }
    </style>
</head>
<body>
    <!-- Left Sidebar -->
    <div class="sidebar-left">
        <div class="sidebar-left-content">
            <!-- Header -->
            <div class="header">
                <span class="header-icon">@</span>
                <span class="header-title">KRCG Graphic Generator</span>
            </div>

            <!-- Text Input -->
            <input type="text" class="text-input" id="textInput" value="RACING FORZA  " placeholder="TEXT GOES HERE...">

            <!-- Colors Panel -->
            <div class="panel">
                <div class="color-section">
                    <div>
                        <span class="control-label">Background Colour</span>
                        <div class="color-swatches" id="bgColorSwatches">
                            <div class="color-swatch active" data-color="82CDFF" style="background-color: #82CDFF;"></div>
                            <div class="color-swatch" data-color="07144a" style="background-color: #07144a;"></div>
                            <div class="color-swatch" data-color="1f3ab6" style="background-color: #1f3ab6;"></div>
                            <div class="color-swatch" data-color="FFFFFF" style="background-color: #FFFFFF;"></div>
                        </div>
                    </div>
                    <div>
                        <span class="control-label">Text Colour</span>
                        <div class="color-swatches" id="fgColorSwatches">
                            <div class="color-swatch" data-color="82CDFF" style="background-color: #82CDFF;"></div>
                            <div class="color-swatch active" data-color="07144a" style="background-color: #07144a;"></div>
                            <div class="color-swatch" data-color="1f3ab6" style="background-color: #1f3ab6;"></div>
                            <div class="color-swatch" data-color="FFFFFF" style="background-color: #FFFFFF;"></div>
                        </div>
                    </div>
                    <div class="toggle-row">
                        <span class="toggle-label">Show 3×3 Grid</span>
                        <input type="checkbox" class="toggle-checkbox" id="gridToggle">
                    </div>
                </div>
            </div>

            <!-- Shape Size & Corner Radius -->
            <div class="panel">
                <div class="slider-panel">
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Shape Size</span>
                            <input type="text" class="slider-value" id="sizeValue" value="280">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="sizeSlider" min="150" max="450" value="280">
                            </div>
                            <button class="reset-btn" data-reset="size">
                                <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M13.5 8C13.5 11.0376 11.0376 13.5 8 13.5C4.96243 13.5 2.5 11.0376 2.5 8C2.5 4.96243 4.96243 2.5 8 2.5" stroke="#334473" stroke-width="1.5" stroke-linecap="round"/>
                                    <path d="M8 5.5V2.5H11" stroke="#334473" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Corner Radius</span>
                            <input type="text" class="slider-value" id="radiusValue" value="60">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="radiusSlider" min="15" max="130" value="60">
                            </div>
                            <button class="reset-btn" data-reset="radius">
                                <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M13.5 8C13.5 11.0376 11.0376 13.5 8 13.5C4.96243 13.5 2.5 11.0376 2.5 8C2.5 4.96243 4.96243 2.5 8 2.5" stroke="#334473" stroke-width="1.5" stroke-linecap="round"/>
                                    <path d="M8 5.5V2.5H11" stroke="#334473" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Rotation Controls -->
            <div class="panel">
                <div class="slider-panel">
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Rotation X</span>
                            <input type="text" class="slider-value" id="rotXValue" value="-45">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="rotXSlider" min="-90" max="90" value="-45">
                            </div>
                            <button class="reset-btn" data-reset="rotX">
                                <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M13.5 8C13.5 11.0376 11.0376 13.5 8 13.5C4.96243 13.5 2.5 11.0376 2.5 8C2.5 4.96243 4.96243 2.5 8 2.5" stroke="#334473" stroke-width="1.5" stroke-linecap="round"/>
                                    <path d="M8 5.5V2.5H11" stroke="#334473" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Rotation Y</span>
                            <input type="text" class="slider-value" id="rotYValue" value="0">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="rotYSlider" min="-180" max="180" value="0">
                            </div>
                            <button class="reset-btn" data-reset="rotY">
                                <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M13.5 8C13.5 11.0376 11.0376 13.5 8 13.5C4.96243 13.5 2.5 11.0376 2.5 8C2.5 4.96243 4.96243 2.5 8 2.5" stroke="#334473" stroke-width="1.5" stroke-linecap="round"/>
                                    <path d="M8 5.5V2.5H11" stroke="#334473" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Rotation Z</span>
                            <input type="text" class="slider-value" id="rotZValue" value="-45">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="rotZSlider" min="-180" max="180" value="-45">
                            </div>
                            <button class="reset-btn" data-reset="rotZ">
                                <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M13.5 8C13.5 11.0376 11.0376 13.5 8 13.5C4.96243 13.5 2.5 11.0376 2.5 8C2.5 4.96243 4.96243 2.5 8 2.5" stroke="#334473" stroke-width="1.5" stroke-linecap="round"/>
                                    <path d="M8 5.5V2.5H11" stroke="#334473" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Offset Controls -->
            <div class="panel">
                <div class="slider-panel">
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Offset X</span>
                            <input type="text" class="slider-value" id="offsetXValue" value="0">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="offsetXSlider" min="-500" max="500" value="0">
                            </div>
                            <button class="reset-btn" data-reset="offsetX">
                                <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M13.5 8C13.5 11.0376 11.0376 13.5 8 13.5C4.96243 13.5 2.5 11.0376 2.5 8C2.5 4.96243 4.96243 2.5 8 2.5" stroke="#334473" stroke-width="1.5" stroke-linecap="round"/>
                                    <path d="M8 5.5V2.5H11" stroke="#334473" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="slider-group">
                        <div class="slider-header">
                            <span class="slider-label">Offset Y</span>
                            <input type="text" class="slider-value" id="offsetYValue" value="0">
                        </div>
                        <div class="slider-row">
                            <div class="slider-track">
                                <input type="range" class="slider" id="offsetYSlider" min="-500" max="500" value="0">
                            </div>
                            <button class="reset-btn" data-reset="offsetY">
                                <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M13.5 8C13.5 11.0376 11.0376 13.5 8 13.5C4.96243 13.5 2.5 11.0376 2.5 8C2.5 4.96243 4.96243 2.5 8 2.5" stroke="#334473" stroke-width="1.5" stroke-linecap="round"/>
                                    <path d="M8 5.5V2.5H11" stroke="#334473" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Branding Footer -->
        <div class="branding">
            <svg class="branding-icon" viewBox="0 0 17 17" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="8.5" cy="8.5" r="7.5" stroke="#82CDFF" stroke-width="1.5"/>
                <path d="M5 8.5H12M8.5 5V12" stroke="#82CDFF" stroke-width="1.5" stroke-linecap="round"/>
            </svg>
            <div class="branding-text">
                <span class="branding-label">A Graphic Tool by</span>
                <span class="branding-name">TYPOGRAAF<span class="branding-copyright">&copy;</span></span>
            </div>
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container">
        <svg id="grid-overlay"></svg>
    </div>

    <!-- Right Sidebar -->
    <div class="sidebar-right">
        <!-- Canvas Size -->
        <div class="panel">
            <span class="control-label">Canvas Size</span>
            <div class="size-grid" id="sizeButtons">
                <button class="size-btn active" data-size="1920x1080">1920×1080</button>
                <button class="size-btn" data-size="1080x1350">1080×1350</button>
                <button class="size-btn" data-size="1080x1920">1080×1920</button>
                <button class="size-btn" data-size="1920x1920">1920×1920</button>
            </div>
        </div>

        <!-- Animation Speed -->
        <div class="panel">
            <div class="slider-group">
                <div class="slider-header">
                    <span class="slider-label">Animation Speed</span>
                    <input type="text" class="slider-value" id="speedValue" value="0.5">
                </div>
                <div class="slider-row">
                    <div class="slider-track">
                        <input type="range" class="slider" id="speedSlider" min="0" max="2" step="0.1" value="0.5">
                    </div>
                    <button class="reset-btn" data-reset="speed">
                        <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M13.5 8C13.5 11.0376 11.0376 13.5 8 13.5C4.96243 13.5 2.5 11.0376 2.5 8C2.5 4.96243 4.96243 2.5 8 2.5" stroke="#334473" stroke-width="1.5" stroke-linecap="round"/>
                            <path d="M8 5.5V2.5H11" stroke="#334473" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Easing Curve -->
        <div class="panel">
            <span class="control-label">Easing Curve</span>
            <div class="easing-container">
                <canvas id="easingCanvas" width="152" height="152"></canvas>
            </div>
            <input type="text" class="easing-input" id="easingInput" value="0.25, 0.25, 0.75, 0.75">
        </div>

        <!-- Output -->
        <div class="panel">
            <span class="control-label">Output</span>
            <div class="output-buttons">
                <button class="output-btn" id="exportPNG">PNG</button>
                <button class="output-btn" id="exportMP4">MP4</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        import * as mp4Muxer from 'https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.3/+esm';
        window.mp4Muxer = mp4Muxer;
    </script>
    <script>
        let scene, camera, renderer, group;
        let textureOffset = 0;
        let currentTexture = null;
        let currentTextureInside = null;
        let animationStartTime = 0;

        const defaultValues = {
            size: 280,
            radius: 60,
            rotX: -45,
            rotY: 0,
            rotZ: -45,
            speed: 0.5,
            offsetX: 0,
            offsetY: 0
        };

        const state = {
            text: 'RACING FORZA  ',
            canvasWidth: 1920,
            canvasHeight: 1080,
            size: 280,
            radius: 60,
            rotX: -45,
            rotY: 0,
            rotZ: -45,
            speed: 0.5,
            bgColor: '82CDFF',
            fgColor: '07144a',
            zoom: 1,
            offsetX: 0,
            offsetY: 0,
            showGrid: false,
            easingP1: { x: 0.25, y: 0.25 },
            easingP2: { x: 0.75, y: 0.75 }
        };

        // Easing editor state
        let easingCanvas, easingCtx;
        let draggingHandle = null;

        function scaleCanvasToFit() {
            const container = document.getElementById('canvas-container');
            const canvas = renderer.domElement;

            requestAnimationFrame(() => {
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;

                const scaleX = containerWidth / state.canvasWidth;
                const scaleY = containerHeight / state.canvasHeight;
                const scale = Math.min(scaleX, scaleY) * 0.9;

                canvas.style.transform = `scale(${scale})`;
                updateGrid();
            });
        }

        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(parseInt(state.bgColor, 16));

            camera = new THREE.PerspectiveCamera(45, state.canvasWidth / state.canvasHeight, 1, 2000);
            camera.position.set(0, 0, 800);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(state.canvasWidth, state.canvasHeight);
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            container.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dir = new THREE.DirectionalLight(0xffffff, 0.5);
            dir.position.set(1, 1, 1);
            scene.add(dir);

            group = new THREE.Group();
            scene.add(group);

            scaleCanvasToFit();

            document.fonts.ready.then(() => {
                build();
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY * -0.001;
                state.zoom = Math.max(0.1, Math.min(3, state.zoom + delta));
                group.scale.set(state.zoom, state.zoom, state.zoom);

                const basePixelRatio = window.devicePixelRatio || 1;
                if (state.zoom > 1) {
                    const zoomPixelRatio = Math.min(basePixelRatio * state.zoom, basePixelRatio * 2);
                    renderer.setPixelRatio(zoomPixelRatio);
                } else {
                    renderer.setPixelRatio(basePixelRatio);
                }
            });

            window.addEventListener('resize', () => {
                scaleCanvasToFit();
            });

            let drag = false, prev = {x:0, y:0};
            renderer.domElement.onmousedown = e => { drag = true; prev = {x: e.clientX, y: e.clientY}; };
            document.onmousemove = e => {
                if (!drag) return;
                state.rotY += (e.clientX - prev.x) * 0.5;
                state.rotX = Math.max(-90, Math.min(90, state.rotX - (e.clientY - prev.y) * 0.3));
                document.getElementById('rotXSlider').value = state.rotX;
                document.getElementById('rotYSlider').value = state.rotY;
                document.getElementById('rotXValue').value = Math.round(state.rotX);
                document.getElementById('rotYValue').value = Math.round(state.rotY);
                updateRotation();
                prev = {x: e.clientX, y: e.clientY};
            };
            document.onmouseup = () => drag = false;

            animate();
        }

        function clearGroup() {
            while (group.children.length) {
                const c = group.children[0];
                group.remove(c);
                c.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (obj.material.map) obj.material.map.dispose();
                        obj.material.dispose();
                    }
                });
            }
        }

        function build() {
            clearGroup();

            const s = state.size;
            const r = Math.min(state.radius, s/2 - 5);

            createTextBand(s, s, r);

            updateRotation();
            updateOffset();
        }

        function createRoundedRectShape(w, h, r) {
            const shape = new THREE.Shape();
            const hw = w/2, hh = h/2;

            shape.moveTo(-hw + r, -hh);
            shape.lineTo(hw - r, -hh);
            shape.quadraticCurveTo(hw, -hh, hw, -hh + r);
            shape.lineTo(hw, hh - r);
            shape.quadraticCurveTo(hw, hh, hw - r, hh);
            shape.lineTo(-hw + r, hh);
            shape.quadraticCurveTo(-hw, hh, -hw, hh - r);
            shape.lineTo(-hw, -hh + r);
            shape.quadraticCurveTo(-hw, -hh, -hw + r, -hh);

            return shape;
        }

        function createTextBand(w, h, r) {
            const hw = w/2, hh = h/2;

            const path = new THREE.Path();
            path.moveTo(-hw + r, hh);
            path.lineTo(hw - r, hh);
            path.quadraticCurveTo(hw, hh, hw, hh - r);
            path.lineTo(hw, -hh + r);
            path.quadraticCurveTo(hw, -hh, hw - r, -hh);
            path.lineTo(-hw + r, -hh);
            path.quadraticCurveTo(-hw, -hh, -hw, -hh + r);
            path.lineTo(-hw, hh - r);
            path.quadraticCurveTo(-hw, hh, -hw + r, hh);

            const points = path.getPoints(100);

            let perimeter = 0;
            for (let i = 1; i < points.length; i++) {
                perimeter += points[i].distanceTo(points[i-1]);
            }
            perimeter += points[points.length - 1].distanceTo(points[0]);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const text = state.text.trim() + ' ';

            const refFontSize = 100;
            const fontFamily = 'Genk, Arial Black, sans-serif';
            ctx.font = `${refFontSize}px ${fontFamily}`;
            const textWidth = ctx.measureText(text).width;

            const textAspect = textWidth / refFontSize;
            const depth = perimeter / textAspect;

            const scale = 6;
            const fontSize = depth * scale * 0.75;

            ctx.font = `${fontSize}px ${fontFamily}`;
            const metrics = ctx.measureText(text);
            const actualTextWidth = metrics.width;

            const ascent = metrics.actualBoundingBoxAscent || fontSize * 0.8;
            const descent = metrics.actualBoundingBoxDescent || fontSize * 0.2;
            const textHeight = ascent + descent;

            canvas.width = Math.ceil(actualTextWidth);
            canvas.height = Math.ceil(textHeight * 1.1);

            const actualDepth = canvas.height / (scale * 0.75);

            ctx.fillStyle = '#' + state.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = `${fontSize}px ${fontFamily}`;
            ctx.fillStyle = '#' + state.fgColor;
            ctx.textBaseline = 'alphabetic';

            const yPos = (canvas.height + ascent - descent) / 2;

            ctx.fillText(text, 0, yPos);

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.needsUpdate = true;

            currentTexture = texture;

            const halfD = actualDepth / 2;

            const vertices = [];
            const uvs = [];
            const indices = [];

            let cumLength = 0;
            const totalLength = perimeter;

            for (let i = 0; i < points.length; i++) {
                const p = points[i];

                if (i > 0) {
                    cumLength += points[i].distanceTo(points[i-1]);
                }
                const u = Math.max(0, Math.min(1, 1 - (cumLength / totalLength)));

                vertices.push(p.x, p.y, halfD);
                vertices.push(p.x, p.y, -halfD);

                uvs.push(u, 1);
                uvs.push(u, 0);

                if (i > 0) {
                    const base = (i - 1) * 2;
                    indices.push(base, base + 3, base + 1);
                    indices.push(base, base + 2, base + 3);
                }
            }

            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geom.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geom.setIndex(indices);
            geom.computeVertexNormals();

            const matOutside = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.FrontSide
            });

            const bandMeshOutside = new THREE.Mesh(geom, matOutside);
            group.add(bandMeshOutside);

            const textureInside = texture.clone();
            textureInside.needsUpdate = true;
            currentTextureInside = textureInside;

            const uvsInside = [];
            cumLength = 0;
            for (let i = 0; i < points.length; i++) {
                if (i > 0) {
                    cumLength += points[i].distanceTo(points[i-1]);
                }
                const u = Math.max(0, Math.min(1, cumLength / totalLength));
                uvsInside.push(u, 1);
                uvsInside.push(u, 0);
            }

            const geomInside = new THREE.BufferGeometry();
            geomInside.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geomInside.setAttribute('uv', new THREE.Float32BufferAttribute(uvsInside, 2));
            geomInside.setIndex(indices);
            geomInside.computeVertexNormals();

            const matInside = new THREE.MeshBasicMaterial({
                map: textureInside,
                side: THREE.BackSide
            });

            const bandMeshInside = new THREE.Mesh(geomInside, matInside);
            group.add(bandMeshInside);

            return actualDepth;
        }

        function updateRotation() {
            group.rotation.x = THREE.MathUtils.degToRad(state.rotX);
            group.rotation.y = THREE.MathUtils.degToRad(state.rotY);
            group.rotation.z = THREE.MathUtils.degToRad(state.rotZ);
        }

        function updateOffset() {
            group.position.set(state.offsetX, state.offsetY, 0);
        }

        function updateGrid() {
            const gridOverlay = document.getElementById('grid-overlay');
            if (!renderer) return;

            const canvas = renderer.domElement;

            if (state.showGrid) {
                gridOverlay.classList.add('visible');

                gridOverlay.setAttribute('width', state.canvasWidth);
                gridOverlay.setAttribute('height', state.canvasHeight);

                const canvasTransform = canvas.style.transform || 'scale(1)';
                gridOverlay.style.transform = `translate(-50%, -50%) ${canvasTransform}`;

                gridOverlay.innerHTML = '';

                const cellWidth = state.canvasWidth / 3;
                const cellHeight = state.canvasHeight / 3;

                for (let i = 1; i < 3; i++) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', cellWidth * i);
                    line.setAttribute('y1', 0);
                    line.setAttribute('x2', cellWidth * i);
                    line.setAttribute('y2', state.canvasHeight);
                    line.setAttribute('stroke', 'rgba(130, 205, 255, 0.5)');
                    line.setAttribute('stroke-width', '2');
                    gridOverlay.appendChild(line);
                }

                for (let i = 1; i < 3; i++) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', 0);
                    line.setAttribute('y1', cellHeight * i);
                    line.setAttribute('x2', state.canvasWidth);
                    line.setAttribute('y2', cellHeight * i);
                    line.setAttribute('stroke', 'rgba(130, 205, 255, 0.5)');
                    line.setAttribute('stroke-width', '2');
                    gridOverlay.appendChild(line);
                }
            } else {
                gridOverlay.classList.remove('visible');
            }
        }

        function cubicBezier(t, p1, p2) {
            const cx = 3 * p1.x;
            const bx = 3 * (p2.x - p1.x) - cx;
            const ax = 1 - cx - bx;

            const cy = 3 * p1.y;
            const by = 3 * (p2.y - p1.y) - cy;
            const ay = 1 - cy - by;

            return ((ay * t + by) * t + cy) * t;
        }

        function solveCubicBezierX(x, p1, p2) {
            if (x <= 0) return 0;
            if (x >= 1) return 1;

            const cx = 3 * p1.x;
            const bx = 3 * (p2.x - p1.x) - cx;
            const ax = 1 - cx - bx;

            let t = x;
            for (let i = 0; i < 8; i++) {
                const currentX = ((ax * t + bx) * t + cx) * t;
                const currentSlope = (3 * ax * t + 2 * bx) * t + cx;
                if (Math.abs(currentSlope) < 1e-6) break;
                t -= (currentX - x) / currentSlope;
            }
            return t;
        }

        function applyEasing(x, p1, p2) {
            const t = solveCubicBezierX(x, p1, p2);
            return cubicBezier(t, p1, p2);
        }

        function drawEasingCurve() {
            if (!easingCanvas || !easingCtx) return;

            const w = easingCanvas.width;
            const h = easingCanvas.height;
            const padding = 12;
            const gridSize = w - padding * 2;

            easingCtx.clearRect(0, 0, w, h);

            // Draw grid
            easingCtx.strokeStyle = '#334473';
            easingCtx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const x = padding + (gridSize / 4) * i;
                const y = padding + (gridSize / 4) * i;
                easingCtx.beginPath();
                easingCtx.moveTo(x, padding);
                easingCtx.lineTo(x, padding + gridSize);
                easingCtx.stroke();
                easingCtx.beginPath();
                easingCtx.moveTo(padding, y);
                easingCtx.lineTo(padding + gridSize, y);
                easingCtx.stroke();
            }

            const toCanvasX = (x) => padding + x * gridSize;
            const toCanvasY = (y) => padding + gridSize - y * gridSize;

            // Draw diagonal line
            easingCtx.strokeStyle = '#82CDFF';
            easingCtx.lineWidth = 1;
            easingCtx.beginPath();
            easingCtx.moveTo(toCanvasX(0), toCanvasY(0));
            easingCtx.lineTo(toCanvasX(1), toCanvasY(1));
            easingCtx.stroke();

            // Draw handles
            const drawHandle = (x, y) => {
                easingCtx.fillStyle = '#82CDFF';
                easingCtx.beginPath();
                easingCtx.arc(toCanvasX(x), toCanvasY(y), 3, 0, Math.PI * 2);
                easingCtx.fill();
            };

            drawHandle(state.easingP1.x, state.easingP1.y);
            drawHandle(state.easingP2.x, state.easingP2.y);
            drawHandle(0, 0);
            drawHandle(1, 1);
        }

        function initEasingEditor() {
            easingCanvas = document.getElementById('easingCanvas');
            easingCtx = easingCanvas.getContext('2d');

            const padding = 12;

            const getGridSize = () => easingCanvas.width - padding * 2;

            const toCanvasCoords = (nx, ny) => {
                const gridSize = getGridSize();
                return {
                    x: padding + nx * gridSize,
                    y: padding + gridSize - ny * gridSize
                };
            };

            const fromCanvasCoords = (cx, cy) => {
                const rect = easingCanvas.getBoundingClientRect();
                const scaleX = easingCanvas.width / rect.width;
                const scaleY = easingCanvas.height / rect.height;
                const gridSize = getGridSize();

                const canvasX = cx * scaleX;
                const canvasY = cy * scaleY;

                return {
                    x: Math.max(0, Math.min(1, (canvasX - padding) / gridSize)),
                    y: Math.max(0, Math.min(1, 1 - (canvasY - padding) / gridSize))
                };
            };

            const getHandleAt = (mouseX, mouseY) => {
                const rect = easingCanvas.getBoundingClientRect();
                const scaleX = easingCanvas.width / rect.width;
                const scaleY = easingCanvas.height / rect.height;

                const canvasX = mouseX * scaleX;
                const canvasY = mouseY * scaleY;

                const p1Pos = toCanvasCoords(state.easingP1.x, state.easingP1.y);
                const p2Pos = toCanvasCoords(state.easingP2.x, state.easingP2.y);

                const dist1 = Math.hypot(canvasX - p1Pos.x, canvasY - p1Pos.y);
                const dist2 = Math.hypot(canvasX - p2Pos.x, canvasY - p2Pos.y);

                if (dist1 < 15) return 'p1';
                if (dist2 < 15) return 'p2';
                return null;
            };

            easingCanvas.addEventListener('mousedown', (e) => {
                const rect = easingCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                draggingHandle = getHandleAt(mouseX, mouseY);
                if (draggingHandle) {
                    e.preventDefault();
                    drawEasingCurve();
                }
            });

            const handleMouseMove = (e) => {
                if (!draggingHandle) return;

                const rect = easingCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const normalized = fromCanvasCoords(mouseX, mouseY);

                if (draggingHandle === 'p1') {
                    state.easingP1.x = normalized.x;
                    state.easingP1.y = normalized.y;
                } else if (draggingHandle === 'p2') {
                    state.easingP2.x = normalized.x;
                    state.easingP2.y = normalized.y;
                }

                updateEasingInput();
                drawEasingCurve();
            };

            const handleMouseUp = () => {
                if (draggingHandle) {
                    draggingHandle = null;
                    drawEasingCurve();
                }
            };

            easingCanvas.addEventListener('mousemove', handleMouseMove);
            easingCanvas.addEventListener('mouseup', handleMouseUp);
            easingCanvas.addEventListener('mouseleave', handleMouseUp);

            document.addEventListener('mousemove', (e) => {
                if (draggingHandle) {
                    handleMouseMove(e);
                }
            });

            document.addEventListener('mouseup', handleMouseUp);

            drawEasingCurve();
        }

        function updateEasingInput() {
            const input = document.getElementById('easingInput');
            const p1x = Math.round(state.easingP1.x * 100) / 100;
            const p1y = Math.round(state.easingP1.y * 100) / 100;
            const p2x = Math.round(state.easingP2.x * 100) / 100;
            const p2y = Math.round(state.easingP2.y * 100) / 100;
            input.value = `${p1x}, ${p1y}, ${p2x}, ${p2y}`;
        }

        function parseEasingInput() {
            const input = document.getElementById('easingInput');
            const parts = input.value.split(',').map(s => parseFloat(s.trim()));

            if (parts.length === 4 && parts.every(p => !isNaN(p))) {
                state.easingP1.x = Math.max(0, Math.min(1, parts[0]));
                state.easingP1.y = Math.max(0, Math.min(1, parts[1]));
                state.easingP2.x = Math.max(0, Math.min(1, parts[2]));
                state.easingP2.y = Math.max(0, Math.min(1, parts[3]));
                drawEasingCurve();
            } else {
                updateEasingInput();
            }
        }

        function animate(timestamp) {
            requestAnimationFrame(animate);

            if (!animationStartTime) animationStartTime = timestamp;

            if (state.speed > 0) {
                const cycleDuration = 2000 / state.speed;
                const elapsed = (timestamp - animationStartTime) % cycleDuration;
                const linearProgress = elapsed / cycleDuration;

                const easedProgress = applyEasing(linearProgress, state.easingP1, state.easingP2);

                const offset = easedProgress;

                if (currentTexture) {
                    currentTexture.offset.x = offset;
                }
                if (currentTextureInside) {
                    currentTextureInside.offset.x = offset;
                }
            }

            renderer.render(scene, camera);
        }

        // Sliders
        const sliders = [
            ['sizeSlider', 'sizeValue', 'size', ''],
            ['radiusSlider', 'radiusValue', 'radius', ''],
            ['rotXSlider', 'rotXValue', 'rotX', ''],
            ['rotYSlider', 'rotYValue', 'rotY', ''],
            ['rotZSlider', 'rotZValue', 'rotZ', ''],
            ['speedSlider', 'speedValue', 'speed', ''],
            ['offsetXSlider', 'offsetXValue', 'offsetX', ''],
            ['offsetYSlider', 'offsetYValue', 'offsetY', '']
        ];

        sliders.forEach(([id, valId, key, suf]) => {
            const slider = document.getElementById(id);
            const valueInput = document.getElementById(valId);

            slider.addEventListener('input', e => {
                state[key] = parseFloat(e.target.value);
                valueInput.value = e.target.value + suf;
                if (key === 'rotX' || key === 'rotY' || key === 'rotZ') updateRotation();
                else if (key === 'offsetX' || key === 'offsetY') updateOffset();
                else if (key !== 'speed') build();
            });

            valueInput.addEventListener('input', e => {
                const numValue = parseFloat(e.target.value.replace(suf, ''));
                if (!isNaN(numValue)) {
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const clampedValue = Math.max(min, Math.min(max, numValue));
                    state[key] = clampedValue;
                    slider.value = clampedValue;
                    valueInput.value = clampedValue + suf;
                    if (key === 'rotX' || key === 'rotY' || key === 'rotZ') updateRotation();
                    else if (key === 'offsetX' || key === 'offsetY') updateOffset();
                    else if (key !== 'speed') build();
                }
            });
        });

        document.getElementById('textInput').addEventListener('input', e => {
            state.text = e.target.value || 'TYPE ';
            build();
        });

        // Reset buttons
        document.querySelectorAll('.reset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const key = btn.dataset.reset;
                const defaultValue = defaultValues[key];
                state[key] = defaultValue;

                const slider = document.getElementById(key + 'Slider');
                const valueInput = document.getElementById(key + 'Value');

                slider.value = defaultValue;
                valueInput.value = defaultValue;

                if (key === 'rotX' || key === 'rotY' || key === 'rotZ') {
                    updateRotation();
                } else if (key === 'offsetX' || key === 'offsetY') {
                    updateOffset();
                } else if (key !== 'speed') {
                    build();
                }
            });
        });

        // Grid toggle
        document.getElementById('gridToggle').addEventListener('change', e => {
            state.showGrid = e.target.checked;
            updateGrid();
        });

        // Easing input
        document.getElementById('easingInput').addEventListener('blur', parseEasingInput);
        document.getElementById('easingInput').addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                parseEasingInput();
                e.target.blur();
            }
        });

        // Background color swatches
        document.querySelectorAll('#bgColorSwatches .color-swatch').forEach(swatch => {
            swatch.addEventListener('click', e => {
                document.querySelectorAll('#bgColorSwatches .color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                state.bgColor = swatch.dataset.color;
                scene.background = new THREE.Color(parseInt(state.bgColor, 16));
                build();
            });
        });

        // Foreground color swatches
        document.querySelectorAll('#fgColorSwatches .color-swatch').forEach(swatch => {
            swatch.addEventListener('click', e => {
                document.querySelectorAll('#fgColorSwatches .color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                state.fgColor = swatch.dataset.color;
                build();
            });
        });

        // Canvas size buttons
        document.querySelectorAll('#sizeButtons .size-btn').forEach(btn => {
            btn.addEventListener('click', e => {
                document.querySelectorAll('#sizeButtons .size-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const [width, height] = btn.dataset.size.split('x').map(Number);
                state.canvasWidth = width;
                state.canvasHeight = height;

                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);

                scaleCanvasToFit();
            });
        });

        // Export PNG
        document.getElementById('exportPNG').addEventListener('click', () => {
            const currentPixelRatio = renderer.getPixelRatio();
            const currentZoom = state.zoom;

            renderer.setPixelRatio(1);
            group.scale.set(1, 1, 1);
            renderer.render(scene, camera);

            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'krcg-graphic-' + Date.now() + '.png';
            link.href = dataURL;
            link.click();

            group.scale.set(currentZoom, currentZoom, currentZoom);
            renderer.setPixelRatio(currentPixelRatio);
        });

        // Export MP4
        let isRecording = false;
        let muxer;
        let videoEncoder;
        let frameNumber = 0;
        let totalFrames = 0;
        let captureFrameId = null;

        document.getElementById('exportMP4').addEventListener('click', async () => {
            const btn = document.getElementById('exportMP4');

            if (isRecording) {
                return;
            }

            isRecording = true;
            frameNumber = 0;

            const cycleDuration = 2000 / state.speed;
            totalFrames = Math.ceil((cycleDuration / 1000) * 60);

            btn.textContent = 'Exporting...';
            btn.style.background = '#82CDFF';
            btn.style.color = '#001550';
            btn.disabled = true;

            await new Promise(resolve => {
                const check = () => {
                    if (window.mp4Muxer) resolve();
                    else setTimeout(check, 50);
                };
                check();
            });

            const { Muxer, ArrayBufferTarget } = window.mp4Muxer;

            const videoWidth = renderer.domElement.width;
            const videoHeight = renderer.domElement.height;

            const target = new ArrayBufferTarget();
            muxer = new Muxer({
                target,
                video: {
                    codec: 'avc',
                    width: videoWidth,
                    height: videoHeight
                },
                fastStart: 'in-memory',
                firstTimestampBehavior: 'offset'
            });

            let encoderFailed = false;
            videoEncoder = new VideoEncoder({
                output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
                error: e => {
                    console.error('Encoder error:', e);
                    encoderFailed = true;
                    isRecording = false;
                    alert('Video encoder failed: ' + e.message);
                    btn.textContent = 'MP4';
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.disabled = false;
                }
            });

            try {
                videoEncoder.configure({
                    codec: 'avc1.640033',
                    width: videoWidth,
                    height: videoHeight,
                    bitrate: 15_000_000,
                    framerate: 60
                });

                await new Promise(resolve => setTimeout(resolve, 100));

                if (encoderFailed || videoEncoder.state !== 'configured') {
                    throw new Error('Encoder failed to configure.');
                }
            } catch (e) {
                console.error('Failed to configure encoder:', e);
                alert('Failed to start video export: ' + e.message);
                isRecording = false;
                btn.textContent = 'MP4';
                btn.style.background = '';
                btn.style.color = '';
                return;
            }

            const captureFrame = () => {
                if (encoderFailed) {
                    return;
                }

                if (frameNumber >= totalFrames) {
                    isRecording = false;

                    videoEncoder.flush().then(() => {
                        videoEncoder.close();
                        muxer.finalize();
                        const { buffer } = muxer.target;
                        const blob = new Blob([buffer], { type: 'video/mp4' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.download = 'krcg-graphic-' + Date.now() + '.mp4';
                        link.href = url;
                        link.click();
                        URL.revokeObjectURL(url);
                        btn.textContent = 'MP4';
                        btn.style.background = '';
                        btn.style.color = '';
                        btn.disabled = false;
                    }).catch(e => {
                        console.error('Error finalizing video:', e);
                        alert('Error creating video: ' + e.message);
                        btn.textContent = 'MP4';
                        btn.style.background = '';
                        btn.style.color = '';
                        btn.disabled = false;
                    });
                    return;
                }

                if (videoEncoder.state !== 'configured') {
                    isRecording = false;
                    return;
                }

                if (videoEncoder.encodeQueueSize > 30) {
                    captureFrameId = setTimeout(captureFrame, 10);
                    return;
                }

                const linearProgress = frameNumber / totalFrames;
                const easedProgress = applyEasing(linearProgress, state.easingP1, state.easingP2);

                if (currentTexture) {
                    currentTexture.offset.x = easedProgress;
                }
                if (currentTextureInside) {
                    currentTextureInside.offset.x = easedProgress;
                }

                renderer.render(scene, camera);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = videoWidth;
                tempCanvas.height = videoHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(renderer.domElement, 0, 0, videoWidth, videoHeight);

                const frame = new VideoFrame(tempCanvas, {
                    timestamp: (frameNumber * 1_000_000) / 60
                });

                videoEncoder.encode(frame, { keyFrame: frameNumber % 60 === 0 });
                frame.close();

                frameNumber++;

                captureFrameId = requestAnimationFrame(captureFrame);
            };

            captureFrame();
        });

        // Load custom font then initialize
        document.fonts.load('100px Genk').then(() => {
            init();
            initEasingEditor();
        }).catch(() => {
            init();
            initEasingEditor();
        });
    </script>
</body>
</html>
