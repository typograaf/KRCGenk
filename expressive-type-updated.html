<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expressive Type</title>
    <style>
        @font-face {
            font-family: 'Genk';
            src: url(data:font/otf;base64,T1RUTwALAIAAAwAwQ0ZGIPwCByUAAARwAAANn0dERUYADwAeAAASEAAAABRHU1VCqSq2HwAAEiQAAABQT1MvMmc9YSsAAAHMAAAAYGNtYXACEgGsAAAD5AAAAGxoZWFkLKJ7mgAAAMQAAAA2aGhlYQeDAqsAAAGoAAAAJGhtdHgm4QLQAAAA/AAAAKxtYXhwACtQAAAAALwAAAAGbmFtZSCbPPEAAAIsAAABtnBvc3T/nwAyAAAEUAAAACAAAFAAACsAAAABAAAAAQAARFOtZF8PPPUAAwPoAAAAAOWOnGYAAAAA5Y6cZgAJ/+gCZQICAAAABwACAAAAAAAAAPoALwAjAAAA3AARANwAEQDcABEA3AARAJwAEQCcABEA3AARANwAEQBuABEA3AARANwAEQCSABEBSgARANwAEQDcABEA3AARAN0AEQDcABEA3AARALYACQDcABEA3AARAUoAEQDcABEA3AARANwAEQDcABEA3AARAHkACQDcABEA3AARANwAEQDcABEA3AARANwAEQDcABEA3AARASQACQH4ABEBSgARAnYAEQABAAACWAAAArwCdgAJAAkCZQABAAAAAAAAAAAAAAAAAAAAKwAEAOcBkAAFAAgCigJYAAAASwKKAlgAAAFeADIA+gAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAABVS1dOAMAAIACgAfQAAAK8AlgAGAAAAAEAAAAAAfQB9AAAACAAAgAAAAgAZgADAAEECQABACQAAAADAAEECQACAA4AJAADAAEECQADAEgAMgADAAEECQAEADQAegADAAEECQAFAD4ArgADAAEECQAGADIA7AADAAEECQAQABQBHgADAAEECQARAB4BMgBnAGUAbgBrADIANgAwADEAMQA1ACAAUgBvAHUAbgBkAGUAZABSAGUAZwB1AGwAYQByADEALgAwADAAMAA7AFUASwBXAE4AOwBnAGUAbgBrADIANgAwADEAMQA1AC0AUgBlAGcAdQBsAGEAcgBSAG8AdQBuAGQAZQBkAGcAZQBuAGsAMgA2ADAAMQAxADUAIABSAGUAZwB1AGwAYQByACAAUgBvAHUAbgBkAGUAZABWAGUAcgBzAGkAbwBuACAAMQAuADAAMAAwADsARwBsAHkAcABoAHMAIAAzAC4ANQAgACgAMwA1ADAAOQApAGcAZQBu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) format('opentype');
            font-weight: normal;
            font-style: normal;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: Helvetica, Arial, sans-serif;
            background: #001550;
            color: #82CDFF;
            display: flex;
        }
        .control-panel {
            width: 300px;
            height: 100%;
            background: #001550;
            border-right: 1px solid #003CC4;
            padding: 24px;
            overflow-y: auto;
            flex-shrink: 0;
        }
        .control-group { margin-bottom: 24px; }
        .control-label {
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            color: #82CDFF;
            margin-bottom: 10px;
            display: block;
        }
        .text-input {
            width: 100%;
            background: #003CC4;
            border: 1px solid #82CDFF;
            border-radius: 6px;
            padding: 12px 14px;
            color: #FFFFFF;
            font-family: inherit;
            font-size: 14px;
        }
        .text-input:focus { outline: none; border-color: #82CDFF; }
        .slider-container { position: relative; }
        .slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #003CC4;
            border-radius: 3px;
            cursor: pointer;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #82CDFF;
            border-radius: 50%;
            cursor: pointer;
        }
        .slider-value {
            position: absolute;
            right: 0;
            top: -20px;
            font-size: 11px;
            color: #82CDFF;
            background: transparent;
            border: none;
            text-align: right;
            width: 50px;
            cursor: text;
        }
        .slider-value:focus {
            outline: none;
            color: #FFFFFF;
        }
        .color-swatches {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        .color-swatch {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }
        .color-swatch:hover {
            border-color: #82CDFF;
        }
        .color-swatch.active {
            border-color: #82CDFF;
        }
        .size-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }
        .size-btn {
            background: #003CC4;
            border: 2px solid transparent;
            border-radius: 6px;
            padding: 10px;
            color: #82CDFF;
            font-family: inherit;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .size-btn:hover {
            border-color: #82CDFF;
        }
        .size-btn.active {
            border-color: #82CDFF;
            background: #82CDFF;
            color: #001550;
        }
        .export-buttons {
            display: flex;
            gap: 8px;
            margin-top: 32px;
        }
        .export-btn {
            flex: 1;
            background: #003CC4;
            border: 1px solid #82CDFF;
            border-radius: 6px;
            padding: 10px;
            color: #82CDFF;
            font-family: inherit;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .export-btn:hover {
            background: #82CDFF;
            color: #001550;
        }
        .export-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #canvas-container {
            flex: 1;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        #canvas-container canvas {
            display: block;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transform-origin: center center;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <div class="control-group">
            <label class="control-label">Text</label>
            <input type="text" class="text-input" id="textInput" value="RACING FORZA  ">
        </div>

        <div class="control-group">
            <label class="control-label">Canvas Size</label>
            <div class="size-buttons" id="sizeButtons">
                <button class="size-btn active" data-size="1920x1080">1920x1080</button>
                <button class="size-btn" data-size="1080x1350">1080x1350</button>
                <button class="size-btn" data-size="1080x1920">1080x1920</button>
                <button class="size-btn" data-size="1920x1920">1920x1920</button>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Background Color</label>
            <div class="color-swatches" id="bgColorSwatches">
                <div class="color-swatch active" data-color="82CDFF" style="background-color: #82CDFF;"></div>
                <div class="color-swatch" data-color="001550" style="background-color: #001550;"></div>
                <div class="color-swatch" data-color="003CC4" style="background-color: #003CC4;"></div>
                <div class="color-swatch" data-color="FFFFFF" style="background-color: #FFFFFF;"></div>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Text Color</label>
            <div class="color-swatches" id="fgColorSwatches">
                <div class="color-swatch" data-color="82CDFF" style="background-color: #82CDFF;"></div>
                <div class="color-swatch active" data-color="001550" style="background-color: #001550;"></div>
                <div class="color-swatch" data-color="003CC4" style="background-color: #003CC4;"></div>
                <div class="color-swatch" data-color="FFFFFF" style="background-color: #FFFFFF;"></div>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Shape Size</label>
            <div class="slider-container">
                <input type="text" class="slider-value" id="sizeValue" value="280">
                <input type="range" class="slider" id="sizeSlider" min="150" max="450" value="280">
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Corner Radius</label>
            <div class="slider-container">
                <input type="text" class="slider-value" id="radiusValue" value="60">
                <input type="range" class="slider" id="radiusSlider" min="15" max="130" value="60">
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Rotation X</label>
            <div class="slider-container">
                <input type="text" class="slider-value" id="rotXValue" value="-45°">
                <input type="range" class="slider" id="rotXSlider" min="-90" max="90" value="-45">
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Rotation Y</label>
            <div class="slider-container">
                <input type="text" class="slider-value" id="rotYValue" value="0°">
                <input type="range" class="slider" id="rotYSlider" min="-180" max="180" value="0">
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Rotation Z</label>
            <div class="slider-container">
                <input type="text" class="slider-value" id="rotZValue" value="-45°">
                <input type="range" class="slider" id="rotZSlider" min="-180" max="180" value="-45">
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Animation Speed</label>
            <div class="slider-container">
                <input type="text" class="slider-value" id="speedValue" value="0.5">
                <input type="range" class="slider" id="speedSlider" min="0" max="2" step="0.1" value="0.5">
            </div>
        </div>

        <div class="export-buttons">
            <button class="export-btn" id="exportPNG">PNG</button>
            <button class="export-btn" id="exportMP4">MP4</button>
        </div>
    </div>
    
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        import * as mp4Muxer from 'https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.3/+esm';
        window.mp4Muxer = mp4Muxer;
    </script>
    <script>
        let scene, camera, renderer, group;
        let textureOffset = 0;
        let currentTexture = null;
        let currentTextureInside = null;
        
        const state = {
            text: 'RACING FORZA  ',
            canvasWidth: 1920,
            canvasHeight: 1080,
            size: 280,
            radius: 60,
            rotX: -45,
            rotY: 0,
            rotZ: -45,
            speed: 0.5,
            bgColor: '82CDFF',
            fgColor: '001550',
            zoom: 1
        };

        function scaleCanvasToFit() {
            const container = document.getElementById('canvas-container');
            const canvas = renderer.domElement;

            // Use a small timeout to ensure container dimensions are calculated
            requestAnimationFrame(() => {
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;

                const scaleX = containerWidth / state.canvasWidth;
                const scaleY = containerHeight / state.canvasHeight;
                const scale = Math.min(scaleX, scaleY) * 0.9; // 90% to add padding

                canvas.style.transform = `scale(${scale})`;
            });
        }
        
        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(parseInt(state.bgColor, 16));

            camera = new THREE.PerspectiveCamera(45, state.canvasWidth / state.canvasHeight, 1, 2000);
            camera.position.set(0, 0, 800);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(state.canvasWidth, state.canvasHeight);
            renderer.setPixelRatio(window.devicePixelRatio || 1); // Use device pixel ratio for sharp rendering
            container.appendChild(renderer.domElement);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dir = new THREE.DirectionalLight(0xffffff, 0.5);
            dir.position.set(1, 1, 1);
            scene.add(dir);
            
            group = new THREE.Group();
            scene.add(group);

            // Scale canvas to fit container
            scaleCanvasToFit();

            // Wait for font to load before building
            document.fonts.ready.then(() => {
                build();
            });

            // Mouse wheel zoom
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY * -0.001;
                state.zoom = Math.max(0.1, Math.min(3, state.zoom + delta));
                group.scale.set(state.zoom, state.zoom, state.zoom);

                // Increase pixel ratio when zoomed in for sharper rendering
                const basePixelRatio = window.devicePixelRatio || 1;
                const zoomPixelRatio = Math.min(basePixelRatio * state.zoom, basePixelRatio * 2); // Cap at 2x
                renderer.setPixelRatio(zoomPixelRatio);
            });

            // Window resize
            window.addEventListener('resize', () => {
                scaleCanvasToFit();
            });

            // Mouse drag
            let drag = false, prev = {x:0, y:0};
            renderer.domElement.onmousedown = e => { drag = true; prev = {x: e.clientX, y: e.clientY}; };
            document.onmousemove = e => {
                if (!drag) return;
                state.rotY += (e.clientX - prev.x) * 0.5;
                state.rotX = Math.max(-90, Math.min(90, state.rotX - (e.clientY - prev.y) * 0.3));
                document.getElementById('rotXSlider').value = state.rotX;
                document.getElementById('rotYSlider').value = state.rotY;
                document.getElementById('rotXValue').textContent = Math.round(state.rotX) + '°';
                document.getElementById('rotYValue').textContent = Math.round(state.rotY) + '°';
                updateRotation();
                prev = {x: e.clientX, y: e.clientY};
            };
            document.onmouseup = () => drag = false;

            animate();
        }
        
        function clearGroup() {
            while (group.children.length) {
                const c = group.children[0];
                group.remove(c);
                c.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (obj.material.map) obj.material.map.dispose();
                        obj.material.dispose();
                    }
                });
            }
        }
        
        function build() {
            clearGroup();
            
            const s = state.size;
            const r = Math.min(state.radius, s/2 - 5);
            
            // Create the text band around the perimeter (this calculates depth)
            createTextBand(s, s, r);

            updateRotation();
        }
        
        function createRoundedRectShape(w, h, r) {
            const shape = new THREE.Shape();
            const hw = w/2, hh = h/2;
            
            shape.moveTo(-hw + r, -hh);
            shape.lineTo(hw - r, -hh);
            shape.quadraticCurveTo(hw, -hh, hw, -hh + r);
            shape.lineTo(hw, hh - r);
            shape.quadraticCurveTo(hw, hh, hw - r, hh);
            shape.lineTo(-hw + r, hh);
            shape.quadraticCurveTo(-hw, hh, -hw, hh - r);
            shape.lineTo(-hw, -hh + r);
            shape.quadraticCurveTo(-hw, -hh, -hw + r, -hh);
            
            return shape;
        }
        
        function createTextBand(w, h, r) {
            const hw = w/2, hh = h/2;
            
            // Get path points around the rounded rectangle
            const path = new THREE.Path();
            path.moveTo(-hw + r, hh);
            path.lineTo(hw - r, hh);
            path.quadraticCurveTo(hw, hh, hw, hh - r);
            path.lineTo(hw, -hh + r);
            path.quadraticCurveTo(hw, -hh, hw - r, -hh);
            path.lineTo(-hw + r, -hh);
            path.quadraticCurveTo(-hw, -hh, -hw, -hh + r);
            path.lineTo(-hw, hh - r);
            path.quadraticCurveTo(-hw, hh, -hw + r, hh);
            
            const points = path.getPoints(100);
            
            // Calculate perimeter length (including closing segment back to start)
            let perimeter = 0;
            for (let i = 1; i < points.length; i++) {
                perimeter += points[i].distanceTo(points[i-1]);
            }
            // Add closing segment
            perimeter += points[points.length - 1].distanceTo(points[0]);
            
            // Create canvas with text - measure first to calculate depth
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const text = state.text.trim() + ' '; // Add single space at end
            
            // Use a reference font size to measure text aspect ratio
            const refFontSize = 100;
            const fontFamily = 'Genk, Arial Black, sans-serif';
            ctx.font = `${refFontSize}px ${fontFamily}`;
            const textWidth = ctx.measureText(text).width;
            
            // Calculate depth so text fits exactly once around perimeter
            const textAspect = textWidth / refFontSize;
            const depth = perimeter / textAspect;
            
            // Now create the actual canvas at proper resolution
            const scale = 6;
            const fontSize = depth * scale * 0.75;
            
            // Canvas width should match the text width at this font size
            ctx.font = `${fontSize}px ${fontFamily}`;
            const metrics = ctx.measureText(text);
            const actualTextWidth = metrics.width;

            // Calculate actual text height with minimal padding
            const ascent = metrics.actualBoundingBoxAscent || fontSize * 0.8;
            const descent = metrics.actualBoundingBoxDescent || fontSize * 0.2;
            const textHeight = ascent + descent;

            canvas.width = Math.ceil(actualTextWidth);
            canvas.height = Math.ceil(textHeight * 1.1); // Add 10% padding

            // Recalculate actual depth based on canvas height so 3D band matches text size
            // Account for the 0.75 multiplier used in fontSize calculation
            const actualDepth = canvas.height / (scale * 0.75);

            // Draw background
            ctx.fillStyle = '#' + state.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw text - calculate proper vertical position using font metrics
            ctx.font = `${fontSize}px ${fontFamily}`;
            ctx.fillStyle = '#' + state.fgColor;
            ctx.textBaseline = 'alphabetic';

            // Position text vertically centered (baseline position)
            const yPos = (canvas.height + ascent - descent) / 2;

            ctx.fillText(text, 0, yPos);

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.needsUpdate = true;

            // Store texture reference for animation (outside face)
            currentTexture = texture;

            // Build band geometry using actual depth
            const halfD = actualDepth / 2;
            
            const vertices = [];
            const uvs = [];
            const indices = [];
            
            let cumLength = 0;
            const totalLength = perimeter;
            
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                
                // Calculate UV x based on distance along perimeter
                if (i > 0) {
                    cumLength += points[i].distanceTo(points[i-1]);
                }
                // U maps 0-1 across the full perimeter, clamped to valid range
                const u = Math.max(0, Math.min(1, 1 - (cumLength / totalLength)));
                
                // Two vertices per point (top and bottom of band)
                vertices.push(p.x, p.y, halfD);   // top
                vertices.push(p.x, p.y, -halfD);  // bottom
                
                uvs.push(u, 1);  // top
                uvs.push(u, 0);  // bottom
                
                // Create faces (two triangles per segment)
                if (i > 0) {
                    const base = (i - 1) * 2;
                    indices.push(base, base + 3, base + 1);
                    indices.push(base, base + 2, base + 3);
                }
            }
            
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geom.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geom.setIndex(indices);
            geom.computeVertexNormals();
            
            // Create outside face (front) - normal rendering
            const matOutside = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.FrontSide
            });

            const bandMeshOutside = new THREE.Mesh(geom, matOutside);
            group.add(bandMeshOutside);

            // Create inside face (back) - needs flipped UVs to scroll same direction
            const textureInside = texture.clone();
            textureInside.needsUpdate = true;
            currentTextureInside = textureInside;

            // Create geometry with flipped UV coordinates for inside face
            const uvsInside = [];
            cumLength = 0;
            for (let i = 0; i < points.length; i++) {
                if (i > 0) {
                    cumLength += points[i].distanceTo(points[i-1]);
                }
                // Flip U coordinate so inside scrolls same visual direction as outside
                const u = Math.max(0, Math.min(1, cumLength / totalLength));
                uvsInside.push(u, 1);  // top
                uvsInside.push(u, 0);  // bottom
            }

            const geomInside = new THREE.BufferGeometry();
            geomInside.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geomInside.setAttribute('uv', new THREE.Float32BufferAttribute(uvsInside, 2));
            geomInside.setIndex(indices);
            geomInside.computeVertexNormals();

            const matInside = new THREE.MeshBasicMaterial({
                map: textureInside,
                side: THREE.BackSide
            });

            const bandMeshInside = new THREE.Mesh(geomInside, matInside);
            group.add(bandMeshInside);

            return actualDepth;
        }
        
        function updateRotation() {
            group.rotation.x = THREE.MathUtils.degToRad(state.rotX);
            group.rotation.y = THREE.MathUtils.degToRad(state.rotY);
            group.rotation.z = THREE.MathUtils.degToRad(state.rotZ);
        }
        
        function animate() {
            requestAnimationFrame(animate);

            // Animate texture offset for both outside and inside faces
            if (state.speed > 0) {
                textureOffset += state.speed * 0.001;
                if (currentTexture) {
                    currentTexture.offset.x = textureOffset;
                }
                if (currentTextureInside) {
                    currentTextureInside.offset.x = textureOffset;
                }
            }

            renderer.render(scene, camera);
        }
        
        // Sliders
        const sliders = [
            ['sizeSlider', 'sizeValue', 'size', ''],
            ['radiusSlider', 'radiusValue', 'radius', ''],
            ['rotXSlider', 'rotXValue', 'rotX', '°'],
            ['rotYSlider', 'rotYValue', 'rotY', '°'],
            ['rotZSlider', 'rotZValue', 'rotZ', '°'],
            ['speedSlider', 'speedValue', 'speed', '']
        ];
        
        sliders.forEach(([id, valId, key, suf]) => {
            const slider = document.getElementById(id);
            const valueInput = document.getElementById(valId);

            // Slider input updates value display
            slider.addEventListener('input', e => {
                state[key] = parseFloat(e.target.value);
                valueInput.value = e.target.value + suf;
                if (key === 'rotX' || key === 'rotY' || key === 'rotZ') updateRotation();
                else if (key !== 'speed') build();
            });

            // Value input updates slider and state
            valueInput.addEventListener('input', e => {
                const numValue = parseFloat(e.target.value.replace(suf, ''));
                if (!isNaN(numValue)) {
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const clampedValue = Math.max(min, Math.min(max, numValue));
                    state[key] = clampedValue;
                    slider.value = clampedValue;
                    valueInput.value = clampedValue + suf;
                    if (key === 'rotX' || key === 'rotY' || key === 'rotZ') updateRotation();
                    else if (key !== 'speed') build();
                }
            });
        });
        
        document.getElementById('textInput').addEventListener('input', e => {
            state.text = e.target.value || 'TYPE ';
            build();
        });

        // Background color swatches
        document.querySelectorAll('#bgColorSwatches .color-swatch').forEach(swatch => {
            swatch.addEventListener('click', e => {
                document.querySelectorAll('#bgColorSwatches .color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                state.bgColor = swatch.dataset.color;
                scene.background = new THREE.Color(parseInt(state.bgColor, 16));
                build();
            });
        });

        // Foreground color swatches
        document.querySelectorAll('#fgColorSwatches .color-swatch').forEach(swatch => {
            swatch.addEventListener('click', e => {
                document.querySelectorAll('#fgColorSwatches .color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                state.fgColor = swatch.dataset.color;
                build();
            });
        });

        // Canvas size buttons
        document.querySelectorAll('#sizeButtons .size-btn').forEach(btn => {
            btn.addEventListener('click', e => {
                document.querySelectorAll('#sizeButtons .size-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const [width, height] = btn.dataset.size.split('x').map(Number);
                state.canvasWidth = width;
                state.canvasHeight = height;

                // Update camera and renderer
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);

                // Scale canvas to fit new dimensions
                scaleCanvasToFit();
            });
        });

        // Export PNG
        document.getElementById('exportPNG').addEventListener('click', () => {
            // Temporarily reset pixel ratio and zoom for export
            const currentPixelRatio = renderer.getPixelRatio();
            const currentZoom = state.zoom;

            renderer.setPixelRatio(1);
            group.scale.set(1, 1, 1);
            renderer.render(scene, camera);

            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'expressive-type-' + Date.now() + '.png';
            link.href = dataURL;
            link.click();

            // Restore zoom and pixel ratio
            group.scale.set(currentZoom, currentZoom, currentZoom);
            renderer.setPixelRatio(currentPixelRatio);
        });

        // Export MP4
        let isRecording = false;
        let muxer;
        let videoEncoder;
        let frameNumber = 0;
        let captureFrameId = null;

        document.getElementById('exportMP4').addEventListener('click', async () => {
            const btn = document.getElementById('exportMP4');

            if (!isRecording) {
                // Start recording
                isRecording = true;
                frameNumber = 0;
                btn.textContent = 'Stop';
                btn.style.background = '#82CDFF';
                btn.style.color = '#001550';

                // Wait for mp4-muxer to load
                await new Promise(resolve => {
                    const check = () => {
                        if (window.mp4Muxer) resolve();
                        else setTimeout(check, 50);
                    };
                    check();
                });

                const { Muxer, ArrayBufferTarget } = window.mp4Muxer;

                // Scale down resolution for video export (max 720p for AVC level 3.1)
                const canvasWidth = renderer.domElement.width;
                const canvasHeight = renderer.domElement.height;
                const maxPixels = 921600; // 1280x720 = max for AVC level 3.1

                let scale = 1;
                const currentPixels = canvasWidth * canvasHeight;
                if (currentPixels > maxPixels) {
                    scale = Math.sqrt(maxPixels / currentPixels);
                }

                const videoWidth = Math.floor(canvasWidth * scale);
                const videoHeight = Math.floor(canvasHeight * scale);

                console.log(`Canvas: ${canvasWidth}x${canvasHeight}, Video: ${videoWidth}x${videoHeight} (${videoWidth * videoHeight} pixels)`);

                // Setup muxer
                const target = new ArrayBufferTarget();
                muxer = new Muxer({
                    target,
                    video: {
                        codec: 'avc',
                        width: videoWidth,
                        height: videoHeight
                    },
                    fastStart: 'in-memory',
                    firstTimestampBehavior: 'offset'
                });

                // Setup video encoder
                let encoderFailed = false;
                videoEncoder = new VideoEncoder({
                    output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
                    error: e => {
                        console.error('Encoder error:', e);
                        encoderFailed = true;
                        isRecording = false;
                        alert('Video encoder failed: ' + e.message);
                        btn.textContent = 'MP4';
                        btn.style.background = '';
                        btn.style.color = '';
                        btn.disabled = false;
                    }
                });

                try {
                    videoEncoder.configure({
                        codec: 'avc1.42001f', // Baseline profile level 3.1 (widely supported)
                        width: videoWidth,
                        height: videoHeight,
                        bitrate: 8_000_000,
                        framerate: 60
                    });

                    // Wait a bit to ensure configuration completes
                    await new Promise(resolve => setTimeout(resolve, 100));

                    if (encoderFailed || videoEncoder.state !== 'configured') {
                        throw new Error('Encoder failed to configure. Resolution: ' + videoWidth + 'x' + videoHeight);
                    }

                    console.log('Encoder configured successfully');
                } catch (e) {
                    console.error('Failed to configure encoder:', e);
                    alert('Failed to start video export: ' + e.message);
                    isRecording = false;
                    btn.textContent = 'MP4';
                    btn.style.background = '';
                    btn.style.color = '';
                    return;
                }

                // Capture frames - render as fast as possible
                const captureFrame = () => {
                    if (encoderFailed) {
                        return;
                    }
                    if (!isRecording) {
                        console.log('Finalizing video...');

                        // Finalize
                        videoEncoder.flush().then(() => {
                            console.log('Encoder flushed, finalizing muxer...');
                            videoEncoder.close();
                            muxer.finalize();
                            const { buffer } = muxer.target;
                            console.log('Muxer finalized, buffer size:', buffer.byteLength);
                            const blob = new Blob([buffer], { type: 'video/mp4' });
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.download = 'expressive-type-' + Date.now() + '.mp4';
                            link.href = url;
                            link.click();
                            console.log('Download triggered');
                            URL.revokeObjectURL(url);
                            btn.textContent = 'MP4';
                            btn.style.background = '';
                            btn.style.color = '';
                            btn.disabled = false;
                        }).catch(e => {
                            console.error('Error finalizing video:', e);
                            alert('Error creating video: ' + e.message);
                            btn.textContent = 'MP4';
                            btn.style.background = '';
                            btn.style.color = '';
                            btn.disabled = false;
                        });
                        return;
                    }

                    // Check if encoder is still configured
                    if (videoEncoder.state !== 'configured') {
                        console.error('Encoder not configured, stopping capture');
                        isRecording = false;
                        return;
                    }

                    // Check if encoder can accept more frames
                    if (videoEncoder.encodeQueueSize > 30) {
                        // Wait a bit if queue is too full
                        captureFrameId = setTimeout(captureFrame, 10);
                        return;
                    }

                    // Render and capture frame
                    renderer.render(scene, camera);

                    // Create canvas at scaled resolution
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = videoWidth;
                    tempCanvas.height = videoHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(renderer.domElement, 0, 0, videoWidth, videoHeight);

                    const frame = new VideoFrame(tempCanvas, {
                        timestamp: (frameNumber * 1_000_000) / 60
                    });

                    videoEncoder.encode(frame, { keyFrame: frameNumber % 60 === 0 });
                    frame.close();

                    frameNumber++;

                    // Render next frame immediately (as fast as possible)
                    captureFrameId = requestAnimationFrame(captureFrame);
                };

                captureFrame();
            } else {
                // Stop recording
                console.log('Stop button clicked');
                isRecording = false;
                btn.textContent = 'Processing...';
                btn.disabled = true;
            }
        });

        // Load custom font then initialize
        document.fonts.load('100px Genk').then(() => {
            init();
        }).catch(() => {
            // Fallback if font fails to load
            init();
        });
    </script>
</body>
</html>
